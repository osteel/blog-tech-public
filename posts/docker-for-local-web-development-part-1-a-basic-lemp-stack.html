<!DOCTYPE html>
<html lang="en">
  <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="https://tech.osteel.me/favicon.ico" />

    <meta name="author" content="Yannick Chenot"/>
    <meta property="og:image" content="https://tech.osteel.me/images/2020/03/04/docker-part-1-01.jpg" />

    <meta name="google-site-verification" content="KhtQOQ0ZVgZ55KSEoXMOWo_seu_e_JbV6xBk_SuewYI" />

    <title>Docker for local web development, part 1: a basic LEMP stack &mdash; osteel's blog</title>

    <meta charset="utf-8" />
    <link href="https://tech.osteel.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="osteel's blog Full Atom Feed" />
    <link href="https://tech.osteel.me/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="osteel's blog Full RSS Feed" />
    <link href="https://tech.osteel.me/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="osteel's blog Atom Feed" />
    <link href="https://tech.osteel.me/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="osteel's blog RSS Feed" />
    <link rel="stylesheet" href="https://tech.osteel.me/theme/css/poole.css"/>
    <link rel="stylesheet" href="https://tech.osteel.me/theme/css/syntax.css"/>
    <link rel="stylesheet" href="https://tech.osteel.me/theme/css/lanyon.css"/>
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
    <link rel="stylesheet" href="https://tech.osteel.me/theme/css/styles.css"/>

    <script
      type="text/javascript"
      src="https://platform-api.sharethis.com/js/sharethis.js#property=5e6053b434311400122fd1f8&product=inline-share-buttons"
      async="async">
    </script>




    <meta name="tags" contents="tutorial" />
    <meta name="tags" contents="docker" />
    <meta name="tags" contents="lemp" />

  </head>

  <body>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="profile">
      <img src="https://www.gravatar.com/avatar/158eb527bb4ceb8e1a84e74b39815b71"/>
    </div>
  </div>

  <section>
    <p>Oh hi! I'm Yannick, a senior backend developer based in Brighton, UK.</p>
  </section>

  <section>
    <ul class="sidebar-nav">
        <li><a class="sidebar-nav-item" href="https://tech.osteel.me/pages/about">About</a></li>
    </ul>
  </section>

  <section>
    <h2>Search</h2>
    <form class="sidebar-nav-item sidebar-nav" action="https://tech.osteel.me/search.html" onsubmit="return (this.elements['q'].value.length > 0)">
        <input class="form-input" type="text" name="q" placeholder="Search" />
    </form>
  </section>

  <section>
    <h2>Categories</h2>
    <nav class="sidebar-nav">
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/blog">Blog</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/contracting.html">Contracting</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/docker">Docker</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/laravel.html">Laravel</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/misc.html">Misc</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/nginx">Nginx</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/php">PHP</a>
        <a class="sidebar-nav-item" href="https://tech.osteel.me/category/vagrant">Vagrant</a>

    </nav>
  </section>

    <section>
        <h2>Find me</h2>
        <ul class="sidebar-nav">
            <li><a class="sidebar-nav-item" href="https://www.osteel.me" target="_blank">Portfolio</a></li>
            <li><a class="sidebar-nav-item" href="https://github.com/osteel" target="_blank">GitHub</a></li>
            <li><a class="sidebar-nav-item" href="https://twitter.com/osteel" target="_blank">Twitter</a></li>
            <li><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/yannickchenot" target="_blank">LinkedIn</a></li>
            <li><a class="sidebar-nav-item" href="http://instagram.com/osteel" target="_blank">Instagram</a></li>
        </ul>
    </section>

  <section>
    <h2>Feeds</h2>
    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">All posts&nbsp;
        [&nbsp;
 <a href="https://tech.osteel.me/feeds/atom.xml" rel="subscribe-atom">Atom</a>        &nbsp;
 <a href="https://tech.osteel.me/feeds/rss.xml" rel="subscribe-rss">RSS</a>        &nbsp;]
      </li>
    </ul>
  </section>

  <div class="sidebar-item">
    <p>
    <a href="https://twitter.com/osteel">&copy; @osteel</a> 2020
    </p>
    <p class="tiny-note">
      Powered by <a href="http://getpelican.com">Pelican</a> :: Theme based on <a class="muted" href="https://github.com/thomaswilley/pelicanyan">Pelicanyan</a>
    </p>
  </div>
</div>    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://tech.osteel.me/" title="Home">osteel's blog</a>
            <small>Web development resources</small>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="posts">
<div class="post">
    <h1 class="post-title">
      Docker for local web development, part 1: a basic LEMP stack
    </h1>
    <span class="post-date">
      <small>
          Last updated: 2020-04-18 ::
        Published: 2020-03-04
          :: [ <a href="https://github.com/osteel/blog-tech-public/commits/master/posts/docker-for-local-web-development-part-1-a-basic-lemp-stack.html">history</a> ]
      </small>
    </span>

    <p><img alt="LEMP stack on Docker" src="/images/2020/03/04/docker-part-1-01.jpg" title="LEMP stack on Docker" /></p>
<h2 id="in-this-series">In this series</h2>
<ul>
<li><a href="/posts/docker-for-local-web-development-introduction-why-should-you-care" title="Docker for local web development, introduction: why should you care?">Introduction: why should you care?</a></li>
<li>Part 1: a basic LEMP stack <strong>⬅️ you are here</strong></li>
<li><a href="/posts/docker-for-local-web-development-part-2-put-your-images-on-a-diet" title="Docker for local web development, part 2: put your images on a diet">Part 2: put your images on a diet</a></li>
<li><a href="/posts/docker-for-local-web-development-part-3-a-three-tier-architecture-with-frameworks" title="Docker for local web development, part 3: a three-tier architecture with frameworks">Part 3: a three-tier architecture with frameworks</a></li>
<li><a href="/posts/docker-for-local-web-development-part-4-smoothing-things-out-with-bash" title="Docker for local web development, part 4: smoothing things out with Bash">Part 4: smoothing things out with Bash</a></li>
<li><a href="/posts/docker-for-local-web-development-part-5-https-all-the-things" title="Docker for local web development, part 5: HTTPS all the things">Part 5: HTTPS all the things</a></li>
<li><a href="/posts/docker-for-local-web-development-part-6-expose-a-local-container-to-the-internet" title="Docker for local web development, part 6: expose a local container to the Internet">Part 6: expose a local container to the Internet</a></li>
<li><a href="/posts/docker-for-local-web-development-part-7-using-a-multi-stage-build-to-introduce-a-worker" title="Docker for local web development, part 7: using a multi-stage build to introduce a worker">Part 7: using a multi-stage build to introduce a worker</a></li>
<li><a href="/posts/docker-for-local-web-development-part-8-scheduled-tasks" title="Docker for local web development, part 8: scheduled tasks">Part 8: scheduled tasks</a></li>
<li><a href="/posts/docker-for-local-web-development-conclusion-where-to-go-from-here" title="Docker for local web development, conclusion: where to go from here">Conclusion: where to go from here</a></li>
<li><a href="/posts/docker-for-local-web-development-appendix-a-docker-on-windows" title="Docker for local web development, appendix A: Docker on Windows">Appendix A: Docker on Windows</a></li>
</ul>
<p>Subscribe to email alerts at the end of this article or follow me on <a href="https://twitter.com/osteel">Twitter</a> to be informed of new publications.</p>
<h2 id="in-this-post">In this post</h2>
<div class="toc">
<ul>
<li><a href="#in-this-series">In this series</a></li>
<li><a href="#in-this-post">In this post</a></li>
<li><a href="#the-first-steps">The first steps</a></li>
<li><a href="#identifying-the-necessary-containers">Identifying the necessary containers</a></li>
<li><a href="#docker-compose">Docker Compose</a><ul>
<li><a href="#nginx">Nginx</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#mysql">MySQL</a></li>
<li><a href="#phpmyadmin">phpMyAdmin</a></li>
</ul>
</li>
<li><a href="#domain-name">Domain name</a></li>
<li><a href="#environment-variables">Environment variables</a></li>
<li><a href="#commands-summary-and-cleaning-up-your-environment">Commands summary and cleaning up your environment</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
<h2 id="the-first-steps">The first steps</h2>
<p>I trust you've already read the <a href="/posts/docker-for-local-web-development-introduction-why-should-you-care" title="Docker for local web development, introduction: why should you care?">introduction</a> to this series and are now ready for some action.</p>
<p>The first thing to do is to head over to the Docker website and <a href="https://www.docker.com/products/docker-desktop">download and install Docker Desktop</a> for Mac or PC, or <a href="https://docs.docker.com/install/">head over here</a> for installation instructions on various Linux distributions.</p>
<p>The second thing you will need is a terminal.</p>
<p class="info"><span class="title">Windows user?</span> If you haven't already, I strongly recommend you read this <a href="/posts/docker-for-local-web-development-appendix-a-docker-on-windows" title="Docker for local web development, appendix A: Docker on Windows">appendix</a> before proceeding any further. It will show you which terminal to use, among other things.</p>

<p>Once both requirements are covered, you can either get the final result from the <a href="https://github.com/osteel/docker-tutorial/tree/part-1">repository</a> and follow this tutorial, or start from scratch and compare your code to the repository's whenever you get stuck. The latter is my recommended approach for Docker beginners, as the various concepts are more likely to stick if you write the code yourself.</p>
<p>Note that this post is quite dense because of the large number of notions being introduced. I assume no prior knowledge of Docker and I try not to leave any detail unexplained. If you are a complete beginner, make sure you have some time ahead of you and grab yourself a hot drink: we're taking the scenic route.</p>
<h2 id="identifying-the-necessary-containers">Identifying the necessary containers</h2>
<p>Docker recommends running only one process per container, which roughly means that each container should be running a single piece of software. Let's remind ourselves what the programs underlying the LEMP stack are:</p>
<ul>
<li><em>L</em> is for Linux;</li>
<li><em>E</em> is for Nginx;</li>
<li><em>M</em> is for MySQL;</li>
<li><em>P</em> is for PHP.</li>
</ul>
<p>Linux is the operating system Docker runs on, so that leaves us with Nginx, MySQL and PHP. For convenience, we will also add phpMyAdmin into the mix. As a result, we now need the following containers:</p>
<ul>
<li>one container for Nginx;</li>
<li>one container for PHP (PHP-FPM);</li>
<li>one container for MySQL;</li>
<li>one container for phpMyAdmin.</li>
</ul>
<p>This is fairly straightforward, but how do we get from here to setting up these containers, and how will they interact with each other?</p>
<h2 id="docker-compose">Docker Compose</h2>
<p>Docker Desktop comes with a tool called <a href="https://docs.docker.com/compose/">Docker Compose</a> that allows you to define and run multi-container Docker applications (if your system runs on Linux, you will need to install it <a href="https://docs.docker.com/compose/install/">separately</a>).</p>
<p>Docker Compose isn't absolutely necessary to manage multiple containers, as doing so can be achieved with Docker alone, but in practice it is very inconvenient to do so (it would be similar to doing long division while there is a calculator on the desk: while it is certainly not a bad skill to have, it is also a tremendous waste of time).</p>
<p>The containers are described in a YAML configuration file and Docker Compose will take care of building the images and starting the containers, as well as some other useful things like automatically connecting the containers to an internal network.</p>
<p>Don't worry if you feel a little confused; by the end of this post it will all make sense.</p>
<h3 id="nginx">Nginx</h3>
<p>The YAML configuration file will actually be our starting point: open your favourite text editor and add a new <code>docker-compose.yml</code> file to a directory of your choice on your local machine (your computer), with the following content:</p>
<pre><code>version: '3.7'

# Services
services:

  # Nginx Service
  nginx:
    image: nginx:1.17
    ports:
      - 80:80
</code></pre>
<p>The <code>version</code> key at the top of the file indicates the version of Docker Compose we intend to use (3.7 is the latest version at the time of writing).</p>
<p>It is followed by the <code>services</code> key, which is a list of the application's components. For the moment we only have the <code>nginx</code> service, with a couple of keys: <code>image</code> and <code>ports</code>. The former indicates which image to use to build our service's container; in our case, version 1.17 of the <a href="https://hub.docker.com/_/nginx">Nginx image</a>. Open the link in a new tab: it will take you to Docker Hub, which is the largest registry for container images (think of it as the <a href="https://packagist.org/">Packagist</a> or <a href="https://pypi.org/">PyPI</a> of Docker).</p>
<p class="info"><span class="title">Why not use the <em>latest</em> tag?</span> You will probably notice that all images have a <em>latest</em> tag corresponding to the most up-to-date version of the image. While it might be tempting to use it, you don't know how the image will evolve in the future – it is very likely that breaking changes will be introduced sooner or later. The same way you do a version freeze for an application's dependencies (via <code>composer.lock</code> for PHP or <code>requirements.txt</code> in Python, for example), using a specific version tag ensures your Docker setup won't break due to unforeseen changes.</p>

<p>Much like a Github repository, image descriptions on Docker Hub usually do a good job at explaining how to use it and what the available versions are. Here, we are looking at Nginx's official image: it is provided for and maintained by Nginx. Docker has become so popular most companies provide their own official image, which I always use whenever possible. They are easily recognisable: their page mentions <em>Docker Official Images</em> at the top, and Docker Hub separates them clearly from the community images when doing a search:</p>
<p><img alt="Docker Hub" src="/images/2020/03/04/docker-part-1-02.png" title="Docker Hub" />
<p class="caption">Note the "Verified Content" at the top</p></p>
<p>Back to <code>docker-compose.yml</code>: under <code>ports</code>, <code>80:80</code> indicates that we want to map our local machine's port 80 (used by HTTP) to the container's. In other words, when we will access port 80 on our local machine (i.e. your computer), we will be forwarded to the port 80 of the Nginx container.</p>
<p>Let's test this out. Save the <code>docker-compose.yml</code> file, open a terminal and change the current directory to your project's before running the following command:</p>
<pre><code>$ docker-compose up -d
</code></pre>
<p>It might take a little while as the Nginx image will first be downloaded from Docker Hub. When it is done, open <a href="http://localhost">localhost</a> in your browser, which should display Nginx's welcome page:</p>
<p><img alt="Nginx" src="/images/2020/03/04/docker-part-1-03.png" title="Nginx" /></p>
<p>Congratulations: you have just created your first Docker container.</p>
<p><img alt="Approval" src="/images/2020/03/04/docker-part-1-04.gif" title="Approval" /></p>
<p>Let's break down that command: by running <code>docker-compose up -d</code>, we essentially asked Docker Compose to build and start the containers described in <code>docker-compose.yml</code>; the <code>-d</code> option indicates that we want to run the containers in the background and get our terminal back.</p>
<p>You can see which containers are currently running by executing the following command:</p>
<pre><code>$ docker-compose ps
</code></pre>
<p>Which should display something similar to this:</p>
<p><img alt="docker-compose ps" src="/images/2020/03/04/docker-part-1-05.png" title="docker-compose ps" /></p>
<p>To stop the containers, simply run:</p>
<pre><code>$ docker-compose stop
</code></pre>
<p>At this point, you might be wondering what the difference is between a service, an image and a container. A service is just one of your application's components, as listed in <code>docker-compose.yml</code>. Each service refers to an image, which is used to start and stop containers based on this image.</p>
<p>To help you grasp the nuance, think of an image as a class, and of a container as an instance of that class.</p>
<p>Speaking of OOP, how about we set up PHP?</p>
<h3 id="php">PHP</h3>
<p>By the end of this section, we will have Nginx serving a simple <code>index.php</code> file via <a href="https://php-fpm.org/">PHP-FPM</a>, which is the most widely used process manager for PHP.</p>
<p class="info"><span class="title">Not a PHP fan?</span> As mentioned in the <a href="/posts/docker-for-local-web-development-introduction-why-should-you-care" title="Docker for local web development, introduction: why should you care?">introduction</a>, while PHP is used on the server side throughout this series, swapping it for another language should be fairly straightforward.</p>

<p>Replace the content of <code>docker-compose.yml</code> with this one:</p>
<pre><code>version: '3.7'

# Services
services:

  # Nginx Service
  nginx:
    image: nginx:1.17
    ports:
      - 80:80
    volumes:
      - ./src:/var/www/php:ro
      - ./.docker/nginx/conf.d:/etc/nginx/conf.d:ro
    depends_on:
      - php

  # PHP Service
  php:
    image: php:7.4-fpm
    working_dir: /var/www/php
    volumes:
      - ./src:/var/www/php
</code></pre>
<p>A few things going on here: let's forget about the Nginx service for a moment, and focus on the new PHP service instead. We start from the <code>php:7.4-fpm</code> image, corresponding to the tag <code>7.4-fpm</code> of <a href="https://hub.docker.com/_/php">PHP's official image</a>, featuring version 7.4 and PHP-FPM. Let's skip <code>working_dir</code> for now, and have a look at <code>volumes</code>. This section allows us to define <em>volumes</em> (basically, directories or single files) that we want to mount onto the container. This essentially means we can map local directories and files to directories and files on the container; in our case, we want Docker Compose to mount the <code>src</code> folder as the container's <code>/var/www/php</code> folder.</p>
<p>What's in the <code>src/</code> folder? Nothing yet, but that's where we are going to place our application code. Once it is mounted onto the container, any change we make to our code will be immediately available, without the need to restart the container.</p>
<p>Create the <code>src</code> directory (at the same level as <code>docker-compose.yml</code>) and add the following <code>index.php</code> file to it:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Hello there&lt;/title&gt;
        &lt;style&gt;
            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;img src="https://tech.osteel.me/images/2020/03/04/hello.gif" alt="Hello there" class="center"&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>It only contains a little bit of HTML and CSS, but all we need for now is to make sure PHP files are correctly served.</p>
<p>Back to the Nginx service: we added a <code>volumes</code> section to it as well, where we mount the directory containing our code just like we did for the PHP service (this is so Nginx gets a copy of <code>index.php</code>, without which it would return a <em>404 Not Found</em> when trying to access the file), and this time we also want to import the Nginx server configuration that will point to our application code:</p>
<pre><code>- ./.docker/nginx/conf.d:/etc/nginx/conf.d
</code></pre>
<p>As Nginx automatically reads files ending with <code>.conf</code> located in the <code>/etc/nginx/conf.d</code> directory, by mounting our own local <code>conf.d</code> directory in its place we make sure the configuration files it contains will be processed by Nginx on the container.</p>
<p>You may have noticed the addition of <code>:ro</code> at the end of both volumes: this option stands for <em>read only</em> and indicates that the container shall not modify the content of these volumes in any way.</p>
<p>Create the <code>.docker/nginx/conf.d</code> folder and add the following <code>php.conf</code> file to it:</p>
<pre><code>server {
    listen 80 default_server;
    listen [::]:80 default_server;
    root   /var/www/php;
    index  index.php;

    location ~* \.php$ {
        fastcgi_pass   php:9000;
        include        fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param  SCRIPT_NAME     $fastcgi_script_name;
    }
}
</code></pre>
<p class="info"><span class="title">Note</span> Placing Docker-related files under a <code>.docker</code> folder is a common practice.</p>

<p>This is a minimalist PHP-FPM server configuration borrowed from <a href="https://www.linode.com/docs/web-servers/nginx/serve-php-php-fpm-and-nginx/">Linode's website</a> that doesn't have much to it; simply notice we point the root to <code>/var/www/php</code>, which is the directory onto which we mount our application code in both our Nginx and PHP containers, and that we set the index to <code>index.php</code>.</p>
<p>The following line is also interesting:</p>
<pre><code>fastcgi_pass php:9000;
</code></pre>
<p>It tells Nginx to forward requests for PHP files to the PHP container's port 9000, which is the default port PHP-FPM listens on. Internally, Docker Compose will automatically resolve the <code>php</code> keyword to whatever private IP address it assigned to the PHP container.</p>
<p>This is another great feature of Docker Compose: at start-up, it will automatically set up an internal network on which each container is discoverable via its service's name.</p>
<p class="info"><span class="title">A word on networks</span> Docker Compose sets up a network with the <em>bridge</em> driver by default, but you can also specify the networks. I've personally never used any other network than the default one, but you can read about other options <a href="https://docs.docker.com/compose/networking/">here</a>.</p>

<p>Finally, let's have a look at the last configuration section of the Nginx service:</p>
<pre><code>depends_on:
  - php
</code></pre>
<p>Sometimes, the order in which Docker Compose starts the containers matters. As we want Nginx to forward PHP requests to the PHP container's port 9000, the following error might occur if Nginx happens to be ready before PHP:</p>
<pre><code>[emerg] 1#1: host not found in upstream "php" in /etc/nginx/conf.d/php.conf:7
nginx_1  | nginx: [emerg] host not found in upstream "php" in /etc/nginx/conf.d/php.conf:7
nginx_1 exited with code 1
</code></pre>
<p>This causes the Nginx process to stop, and as the Nginx container will only run for as long as the Nginx process is up, the container stops as well. The <code>depends_on</code> configuration ensures the PHP container will start before the Nginx one, saving us an embarrassing situation.</p>
<p>Your directory and file structure should now look similar to this:</p>
<pre><code>docker-tutorial/
├── .docker/
│   └── nginx/
│       └── conf.d/
│           └── php.conf
├── src/
│   └── index.php
└── docker-compose.yml
</code></pre>
<p>We are ready for another test. Go back to your terminal and run the same command again (this time, the PHP image will be downloaded):</p>
<pre><code>$ docker-compose up -d
</code></pre>
<p>Refresh <a href="http://localhost">localhost</a>: if everything went well you will be greeted by the man who can disappear in a bathrobe.</p>
<p>Update <code>index.php</code> (modify the content of the <code>&lt;title&gt;</code> tag, for instance) and reload the page: the change should appear immediately.</p>
<p>If you run <code>docker-compose ps</code> you will observe that you now have two containers running: <code>nginx_1</code> and <code>php_1</code>.</p>
<p>Let's inspect the PHP container:</p>
<pre><code>$ docker-compose exec php bash
</code></pre>
<p>By running this command, we ask Docker Compose to execute Bash on the PHP container. You should get a new prompt indicating that you are currently under <code>/var/www/php</code>: this is what the <code>working_directory</code> configuration we ran into earlier is for. Run a simple <code>ls</code> to list the content of the directory: you should see <code>index.php</code>, which is expected as we mounted our local <code>src</code> folder onto the container's <code>/var/www/php</code> folder.</p>
<p>Run <code>exit</code> to leave the container.</p>
<p>Before we move on to the next section, let me show you one last trick. Go back to your terminal and run the following command:</p>
<pre><code>$ docker-compose logs -f
</code></pre>
<p>Wait for a few logs to display, and hit the <em>return</em> key a few times to add some empty lines. Refresh <a href="http://localhost">localhost</a> again and take another look at your terminal, which should have printed some new lines:</p>
<p><img alt="docker-compose logs" src="/images/2020/03/04/docker-part-1-06.png" title="docker-compose logs" /></p>
<p>This command aggregates the logs of every container, which is extremely useful for debugging: if anything goes wrong, your first reflex should always be to look at the logs. It is also possible to display the information of a specific container simply by appending the name of the service (e.g. <code>docker-compose logs -f nginx</code>).</p>
<p>Hit <code>ctrl+c</code> to get your terminal back.</p>
<h3 id="mysql">MySQL</h3>
<p>The last key component of our LEMP stack is MySQL. Let's update <code>docker-compose.yml</code> again:</p>
<pre><code>version: '3.7'

# Services
services:

  # Nginx Service
  nginx:
    image: nginx:1.17
    ports:
      - 80:80
    volumes:
      - ./src:/var/www/php:ro
      - ./.docker/nginx/conf.d:/etc/nginx/conf.d:ro
    depends_on:
      - php

  # PHP Service
  php:
    build: ./.docker/php
    working_dir: /var/www/php
    volumes:
      - ./src:/var/www/php
    depends_on:
      - mysql

  # MySQL Service
  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: demo
    volumes:
      - ./.docker/mysql/my.cnf:/etc/mysql/conf.d/my.cnf:ro
      - mysqldata:/var/lib/mysql

# Volumes
volumes:

  mysqldata:
</code></pre>
<p>The Nginx service is still the same, but the PHP one was slightly updated. We are already familiar with <code>depends_on</code>: this time, we indicate that the new MySQL service should be started before PHP. But before we dive into its configuration, let's take a look at the new <code>build</code> section of the PHP service, which seemingly replaced the <code>image</code> one. Instead of using the official PHP image as is, we tell Docker Compose to use the <em>Dockerfile</em> from <code>.docker/php</code> to build a new image.</p>
<p>A Dockerfile is like the recipe to build an image: every image has one, even official ones (see for instance <a href="https://github.com/nginxinc/docker-nginx/blob/5971de30c487356d5d2a2e1a79e02b2612f9a72f/mainline/buster/Dockerfile">Nginx's</a>).</p>
<p>Create the <code>.docker/php</code> folder and add a file named <code>Dockerfile</code> to it, with the following content:</p>
<pre><code>FROM php:7.4-fpm

RUN docker-php-ext-install pdo_mysql
</code></pre>
<p>PHP needs the <code>pdo_mysql</code> extension in order to read from a MySQL database. Although it doesn't come with the official image, <a href="https://hub.docker.com/_/php">the Docker Hub description</a> provides some instructions to install PHP extensions easily. At the top of our Dockerfile, we indicate that we start from the official image, and we proceed with installing <code>pdo_mysql</code> with a <code>RUN</code> command. And that's it! Next time we start our containers, Docker Compose will pick up the changes and build a new image based on the recipe we gave it.</p>
<p>A lot more can be done with a Dockerfile, and while this is a very basic example some more advanced use cases will be covered in subsequent articles.</p>
<p>For the time being, let's update <code>index.php</code> to leverage the new extension:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Hello there&lt;/title&gt;
        &lt;style&gt;
            body {
                font-family: "Arial", sans-serif;
                font-size: larger;
            }

            .center {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 50%;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;img src="https://tech.osteel.me/images/2020/03/04/hello.gif" alt="Hello there" class="center"&gt;
        &lt;?php
        $connection = new PDO('mysql:host=mysql;dbname=demo;charset=utf8', 'root', 'root');
        $query      = $connection-&gt;query("SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'demo'");
        $tables     = $query-&gt;fetchAll(PDO::FETCH_COLUMN);

        if (empty($tables)) {
            echo '&lt;p class="center"&gt;There are no tables in database &lt;code&gt;demo&lt;/code&gt;.&lt;/p&gt;';
        } else {
            echo '&lt;p class="center"&gt;Database &lt;code&gt;demo&lt;/code&gt; contains the following tables:&lt;/p&gt;';
            echo '&lt;ul class="center"&gt;';
            foreach ($tables as $table) {
                echo "&lt;li&gt;{$table}&lt;/li&gt;";
            }
            echo '&lt;/ul&gt;';
        }
        ?&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The main change is the addition of a few lines of PHP code to connect to a database that does not exist yet. Let's now have a look at the MySQL service in <code>docker-compose.yml</code>: the <code>image</code> section points to MySQL's <a href="https://hub.docker.com/_/mysql">official image</a> for version 8, and it is followed by a section we haven't come across yet: <code>environment</code>. It contains a couple of keys, <code>MYSQL_ROOT_PASSWORD</code> and <code>MYSQL_DATABASE</code>, which are environment variables that will be set on the container upon creation. They are documented in the <a href="https://hub.docker.com/_/mysql">image's description</a> and essentially allow us to set the root password and create a default database respectively.</p>
<p>In other words, a <code>demo</code> database will automatically be created for us when the container starts.</p>
<p>After the <code>environment</code> key is the now familiar <code>volumes</code>. The first volume is a configuration file (in <em>read only</em> mode) we will be using to set the character set to <code>utf8mb4_unicode_ci</code> by default, which is pretty standard nowadays.</p>
<p>Create the <code>.docker/mysql</code> folder and add the following <code>my.cnf</code> file to it:</p>
<pre><code>[mysqld]
collation-server     = utf8mb4_unicode_ci
character-set-server = utf8mb4
</code></pre>
<div class="info">
<p><span class="title">Password plugin error?</span> Some versions of PHP prior to 7.4 are incompatible with MySQL's new default password plugin introduced with version 8. If you require an older version of PHP, you might also need to add the following line to the configuration file:</p>
<pre>default-authentication-plugin = mysql_native_password</pre>
</div>

<p>The second volume looks a bit different than what we have seen so far: instead of pointing to a local folder, it refers to a named volume defined in a whole new <code>volumes</code> section which sits at the same level as <code>services</code>:</p>
<pre><code># Volumes
volumes:

  mysqldata:
</code></pre>
<p>We need such a volume because without it, every time the <code>mysql</code> service container is destroyed the database is destroyed with it. To make it persistent, we basically tell the MySQL container to use the <code>mysqldata</code> volume to store the data locally, <code>local</code> being the default driver (just like networks, volumes come with various drivers and options which you can learn about <a href="https://docs.docker.com/compose/compose-file/#volumes-for-services-swarms-and-stack-files">here</a>). As a result, a local directory is mounted onto the container, the difference being that instead of specifying which one, we let Docker Compose pick a location.</p>
<p>Go back to your terminal and run <code>docker-compose up -d</code> again. Once it is done downloading the MySQL image and all of the containers are up and running, refresh <a href="http://localhost">localhost</a>. You should see this:</p>
<p><img alt="Hello there" src="/images/2020/03/04/docker-part-1-07.png" title="Hello there" /></p>
<div class="info">
<p><span class="title">Connection error?</span> You might initially get the following error: <code>Fatal error: Uncaught PDOException: SQLSTATE[HY000] [2002] Connection refused</code>. The reason is that MySQL hasn't built the <code>demo</code> database just yet, even though we specifically instructed the MySQL container to be started before the PHP one. The problem is the MySQL container is indeed started first, but only then does it proceed with creating the database, which means the PHP container might be ready before the database is.</p>
<p>Keep refreshing for a few seconds; the error will eventually disappear.</p>
</div>

<p>We now have Nginx serving PHP files that can connect to a MySQL database, meaning our LEMP stack is pretty much complete. The next steps are about improving our setup, starting with seeing how we can interact with the database in a user-friendly way.</p>
<h3 id="phpmyadmin">phpMyAdmin</h3>
<p>When it comes to dealing with a MySQL database, <a href="https://www.phpmyadmin.net/">phpMyAdmin</a> remains a popular choice; conveniently, they provide a <a href="https://hub.docker.com/r/phpmyadmin/phpmyadmin">Docker image</a> which is pretty straightforward to set up.</p>
<div class="info">
<p><span class="title">Not using phpMyAdmin?</span> If you are used to some other tool like <a href="https://github.com/Sequel-Ace/Sequel-Ace">Sequel Ace</a> or <a href="https://www.mysql.com/products/workbench">MySQL Workbench</a>, you can simply update the MySQL configuration in <code>docker-compose.yml</code> and add a <code>ports</code> section mapping your local machine's port 3306 to the container's:</p>
<pre>
    ...
      ports:
        - 3306:3306
    ...
</pre>
<p>From there, all you need to do is configure a database connection in your software of choice, setting <code>localhost:3306</code> as the host and <code>root</code>, <code>root</code> as login and password to access the MySQL database while the container is running.</p>
<p>If you choose to do the above, you can skip this section altogether and move on to the next one.</p>
</div>

<p>Open <code>docker-compose.yml</code> one last time and add the following service configuration after MySQL's:</p>
<pre><code>  # PhpMyAdmin Service
  phpmyadmin:
    image: phpmyadmin/phpmyadmin:5
    ports:
      - 8080:80
    environment:
      PMA_HOST: mysql
    depends_on:
      - mysql
</code></pre>
<p>We start from version 5 of the image and we map the local machine's port 8080 to the container's port 80. We indicate the MySQL container should be started first with <code>depends_on</code>, and set the host that phpMyAdmin should connect to using the <code>PMA_HOST</code> environment variable (remember that Docker Compose will automatically resolve <code>mysql</code> to the private IP address it assigned to the container).</p>
<p>Save the changes and run <code>docker-compose up -d</code> again. The image will be downloaded, then, once everything is up, visit <a href="http://localhost:8080">localhost:8080</a>:</p>
<p><img alt="phpMyAdmin" src="/images/2020/03/04/docker-part-1-08.png" title="phpMyAdmin" /></p>
<p>Enter <code>root</code> / <code>root</code> as username and password, create a couple of tables under the <code>demo</code> database and refresh <a href="http://localhost">localhost</a> to confirm they are correctly listed.</p>
<p>And that's it! That one was easy, right?</p>
<p>Let's move on to setting up a proper domain name for our application.</p>
<h2 id="domain-name">Domain name</h2>
<p>We have come a long way already and all that's left for today mostly boils down to polishing up our setup. While accessing <a href="http://localhost">localhost</a> is functional, it is not particularly user friendly.</p>
<p>Replace the content of <code>.docker/nginx/conf.d/php.conf</code> with this one:</p>
<pre><code>server {
    listen      80;
    listen      [::]:80;
    server_name php.test;
    root        /var/www/php;
    index       index.php;

    location ~* \.php$ {
        fastcgi_pass   php:9000;
        include        fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param  SCRIPT_NAME     $fastcgi_script_name;
    }
}
</code></pre>
<p>We essentially removed <code>default_server</code> (since the server will now be identified by a domain name) and added the <code>server_name</code> configuration, giving it the value <code>php.test</code>, which will be our application's address.</p>
<p>There is one extra step we need to take for this to work: as <code>php.test</code> is not a real domain name (it is not registered anywhere), you need to edit your local machine's <code>hosts</code> file so it recognises it.</p>
<p class="info"><span class="title">Where to find the <em>hosts</em> file?</span> On UNIX-based systems (essentially Linux distributions and macOS), it is located at <code>/etc/hosts</code>. On Windows, it should be located at <code>c:\windows\system32\drivers\etc\hosts</code>. You will need to edit it as administrator (<a href="https://www.howtogeek.com/howto/27350/beginner-geek-how-to-edit-your-hosts-file/">this tutorial</a> should help if you are unsure how to do that).</p>

<p>Add the following line to your <code>hosts</code> file and save it:</p>
<pre><code>127.0.0.1 php.test
</code></pre>
<p>Since we haven't updated <code>docker-compose.yml</code> nor any Dockerfile, this time a simple <code>docker-compose up -d</code> won't be enough for Docker Compose to pick up the changes. We need to explicitly tell it to restart the containers so the Nginx process is restarted and the new configuration is taken into account:</p>
<pre><code>$ docker-compose restart
</code></pre>
<p>Your application is now available at <a href="http://php.test">php.test</a>, as well as <a href="http://localhost">localhost</a>.</p>
<h2 id="environment-variables">Environment variables</h2>
<p>We are almost there, folks! The last thing I want to show you today is how to set environment variables for the whole Docker Compose project, rather than for a specific service like we have been doing so far (using the <code>environment</code> section in <code>docker-compose.yml</code>).</p>
<p>Before we do that, I would like you to list the current containers:</p>
<pre><code>$ docker-compose ps
</code></pre>
<p>Notice how each container is prefixed by the name of your project directory (which would be <code>docker-tutorial</code> if you cloned the <a href="https://github.com/osteel/docker-tutorial/tree/part-1">repository</a>):</p>
<p><img alt="docker-compose ps with prefix" src="/images/2020/03/04/docker-part-1-09.png" title="docker-compose ps with prefix" /></p>
<p>Now, before we proceed further, let's destroy our containers and volumes so we can start afresh:</p>
<pre><code>$ docker-compose down -v
</code></pre>
<p>Create a <code>.env</code> file alongside <code>docker-compose.yml</code>, with the following content:</p>
<pre><code>COMPOSE_PROJECT_NAME=demo
</code></pre>
<p>Save the file and run <code>docker-compose up -d</code> again, followed by <code>docker-compose ps</code>: each container is now prefixed with <code>demo_</code>.</p>
<p>Why is this important? By assigning a unique name to your project, you ensure that no name collision will happen with other ones. If there are multiple Docker-based projects on your system that share the same name or directory name, and more than one use a service called <code>nginx</code>, Docker may complain that another container named <code>xxx_nginx</code> already exists when you bring up a Docker environment.</p>
<p>While this might not seem essential, it is an easy way to avoid potential hassle in the future, and provides some consistency across the team. Speaking of which: if you've dealt with <code>.env</code> files before, you probably know that they are not supposed to be versioned and pushed to a code repository. Assuming you are using Git, you should add <code>.env</code> to a <code>.gitignore</code> file, and create a <code>.env.example</code> file that will be shared with your coworkers.</p>
<p>Here is what the final directory and file structure should look like:</p>
<pre><code>docker-tutorial/
├── .docker/
│   ├── mysql/
│   │   └── my.cnf
│   ├── nginx/
│   │   └── conf.d/
│   │       └── php.conf
│   └── php/
│       └── Dockerfile
├── src/
│   └── index.php
├── .env
├── .env.example
├── .gitignore
└── docker-compose.yml
</code></pre>
<p>That is the extent to which we need environment variables for this article, but you can read more about them <a href="https://docs.docker.com/compose/environment-variables/">over here</a>.</p>
<h2 id="commands-summary-and-cleaning-up-your-environment">Commands summary and cleaning up your environment</h2>
<p>Before we wrap up, I'd like to summarise all of the commands we have been using so far, and throw a few more in so you can clean up your environment if you wish to. This can be used as a reference you can easily come back to if need be, especially in the beginning.</p>
<p>Remember that they need to be run from your project's directory.</p>
<p><em>Start and run the containers in the background</em></p>
<pre><code>$ docker-compose up -d
</code></pre>
<p>If you update <code>docker-compose.yml</code>, an image or a Dockerfile, running this command again will pick up the changes automatically.</p>
<p><em>Restart the containers</em></p>
<pre><code>$ docker-compose restart
</code></pre>
<p>Useful when some changes require a process to restart, e.g. restart Nginx to pick up some server configuration changes.</p>
<p><em>List the containers</em></p>
<pre><code>$ docker-compose ps
</code></pre>
<p><em>Tail the containers' logs</em></p>
<pre><code>$ docker-compose logs [service]
</code></pre>
<p>Replace <code>[service]</code> with a service name (e.g. <code>nginx</code>) to display this service's logs only.</p>
<p><em>Stop the containers</em></p>
<pre><code>$ docker-compose stop
</code></pre>
<p><em>Stop and/or destroy the containers</em></p>
<pre><code>$ docker-compose down
</code></pre>
<p><em>Stop and/or destroy the containers and their volumes (including named volumes)</em></p>
<pre><code>$ docker-compose down -v
</code></pre>
<p><em>Delete everything, including images</em></p>
<pre><code>$ docker-compose down -v --rmi all
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Here is a summary of what we have covered today:</p>
<ul>
<li>what Docker Compose is;</li>
<li>what the difference between a service, an image and a container is;</li>
<li>how to search for images on Docker Hub;</li>
<li>what running a single process per container means;</li>
<li>how to split our application into different containers accordingly;</li>
<li>how to describe services in a <code>docker-compose.yml</code> file;</li>
<li>what a <code>Dockerfile</code> is;</li>
<li>how to declare and use volumes;</li>
<li>how Docker Compose makes containers discoverable on an internal network;</li>
<li>how to assign a domain name to our application;</li>
<li>how to set environment variables;</li>
<li>a bunch of useful commands.</li>
</ul>
<p>That is an awful lot to digest. Congratulations if you made it this far, that must have been a real effort. The good news is that the next posts will be lighter, and the result of this one can already be used as a decent starting point for any web project.</p>
<p>Don't worry if you feel a little bit confused or overwhelmed, that is perfectly normal. Docker is a strong case for <em>practice makes perfect</em>: it is only by using it regularly that its concepts eventually click.</p>
<p>In the <a href="/posts/docker-for-local-web-development-part-2-put-your-images-on-a-diet" title="Docker for local web development, part 2: put your images on a diet">next part</a> of this series, we will see how to choose and shrink the size of our images. Subscribe to email alerts below so you don't miss it, or follow me on <a href="https://twitter.com/osteel">Twitter</a> where I will share my posts as soon as they are published.</p>

    <p class="meta">
      <small>
        Last updated by osteel on the
          <time datetime="2020-04-18" pubdate>2020-04-18</time>
          :: [
          <a href="https://tech.osteel.me/tag/tutorial">tutorial</a>
          <a href="https://tech.osteel.me/tag/docker">docker</a>
          <a href="https://tech.osteel.me/tag/lemp">lemp</a>
          ]
      </small>
    </p>

    <div class="sharethis-inline-share-buttons"></div>

    <section>
      <h2>Like this?</h2>
      <form action="https://osteel.us5.list-manage.com/subscribe/post?u=dda32a39af10ca5ed21d00084&amp;id=e1b6d5529d" method="post" id="subscribe-form" name="mc-embedded-subscribe-form" target="_blank" novalidate>
        <label for="mce-EMAIL">Get notified of future posts by email:</label>
        <input type="email" value="" name="EMAIL" id="mce-EMAIL" class="form-input" placeholder="email address" required>
        <input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="form-button">
        <input type="checkbox" value="" name="group[23889][2]" style="display:none" checked>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_dda32a39af10ca5ed21d00084_e1b6d5529d" tabindex="-1" value=""></div>
        <p class="tiny-note">You can unsubscribe at any time by clicking the link in the footer of the emails.<br>By clicking to subscribe, you acknowledge that your email address will be transferred to Mailchimp for processing.<br>Learn more about Mailchimp's privacy practices <a href="https://mailchimp.com/legal/" target="_blank">here</a>.</p>
      </form>
    </section>

    <section>
      <h2>Comments</h2>
      <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
    </section>
  </div>
</div>
      </div>

      <label for="sidebar-checkbox" class="sidebar-toggle"></label>

      <script>
        (function(document) {
          var i = 0;
          // snip empty header rows since markdown can't
          var rows = document.querySelectorAll('tr');
          for(i=0; i<rows.length; i++) {
            var ths = rows[i].querySelectorAll('th');
            var rowlen = rows[i].children.length;
            if (ths.length > 0 && ths.length === rowlen) {
              rows[i].remove();
            }
          }
        })(document);
      </script>

      <script>
        /* Lanyon & Poole are Copyright (c) 2014 Mark Otto. Adapted to Pelican 20141223 and extended a bit by @thomaswilley */
        (function(document) {
          var toggle = document.querySelector('.sidebar-toggle');
          var sidebar = document.querySelector('#sidebar');
          var checkbox = document.querySelector('#sidebar-checkbox');
          document.addEventListener('click', function(e) {
            var target = e.target;
            if(!checkbox.checked ||
            sidebar.contains(target) ||
            (target === checkbox || target === toggle)) return;
            checkbox.checked = false;
            }, false);
            })(document);
      </script>


      <script type="text/javascript">
        var disqus_shortname = "osteel";
              var disqus_identifier = "/posts/docker-for-local-web-development-part-1-a-basic-lemp-stack";
              var disqus_url = "https://tech.osteel.me/posts/docker-for-local-web-development-part-1-a-basic-lemp-stack";
              var disqus_title = "Docker for local web development, part 1: a basic LEMP stack";
        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
      </script>

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-53994673-2']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-53994673-2');
    ga('send', 'pageview');
</script>

     </div>
  </body>
</html>